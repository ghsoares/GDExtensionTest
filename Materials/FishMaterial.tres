[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform vec4 baseColor : hint_color = vec4(.5, .5, .5, 1.0);
uniform vec4 startColor : hint_color = vec4(1.0, .25, .25, 1.0);
uniform float hueDifference = .65;
uniform float waveSpeed = 1.0;
uniform float waveMagnitude = .1;
uniform float waveFrequency = 2.0;

varying float instanceIndex;

vec3 rgb_to_hsv(vec3 rgb) {
	vec3 c = rgb;
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
	vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv_to_rgb(vec3 hsv) {
	vec3 c = hsv;
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsvShift(vec3 col, vec3 shift) {
	return hsv_to_rgb(fract(rgb_to_hsv(col) + shift));
}

void vertex() {
	
	instanceIndex = INSTANCE_CUSTOM.r * 16.0;
	
}

void fragment() {
	float pi = radians(180.0) * waveFrequency;
	
	vec2 uv = UV;
	uv.y += sin(uv.x * pi + TIME * waveSpeed) * waveMagnitude;
	vec4 col = texture(TEXTURE, uv);
	
	vec3 t = step(.99, 1.0 - clamp(abs(col.rgb - baseColor.rgb), 0.0, 1.0));
	
	vec3 color = startColor.rgb;
	color = rgb_to_hsv(color);
	color.r += instanceIndex * hueDifference;
	color = hsv_to_rgb(color);
	
	col.rgb = mix(col.rgb, color.rgb, t);
	
	COLOR = col;
}"

[resource]
shader = SubResource( 1 )
shader_param/baseColor = Color( 0.490196, 0.490196, 0.490196, 1 )
shader_param/startColor = Color( 1, 0.254902, 0.254902, 1 )
shader_param/hueDifference = 0.618
shader_param/waveSpeed = 16.0
shader_param/waveMagnitude = 0.11
shader_param/waveFrequency = 1.25
