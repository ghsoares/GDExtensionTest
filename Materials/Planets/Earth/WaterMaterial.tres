[gd_resource type="ShaderMaterial" load_steps=4 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform mat4 worldMatrix;

uniform vec4 color: hint_color = vec4(.5, .9, 1.0, .5);
uniform vec4 color2: hint_color = vec4(.5, .9, 1.0, .5);
uniform vec4 surfaceColor: hint_color = vec4(1.0);
uniform float surfaceSize = 2.0;
uniform float colorTransition = 32.0;
uniform float colorTransitionSteps = 8.0;

uniform float windSpeed;

uniform sampler2D refractionTexture;
uniform vec2 refractionMotion;
uniform float refractionTiling = 32;
uniform float refractionPower = 4.0;

uniform int waveOctaves = 1;
uniform float wavePeriod = 64;
uniform float waveLacunarity = 2.0;
uniform float wavePersistance = .25;

uniform float limitTransition = 32.0;

varying vec2 v;
varying vec2 worldV;
varying float time;

void vertex() {
	v = VERTEX;
	time = TIME;
	worldV = (worldMatrix * vec4(VERTEX, 0.0, 1.0)).rg;
}

float GetWaveHeight() {
	float pi = radians(360.0);
	
	float h = 0.0;
	int oct = max(waveOctaves, 1);
	
	float period = wavePeriod;
	float pers = 1.0;
	for (int i = 0; i < oct; i++) {
		float s = sin((worldV.x / period) * pi - windSpeed * time * .5) * .5 + .5;
		h += s * pers;
		
		period /= waveLacunarity;
		pers *= wavePersistance;
	}
	
	h *= abs(windSpeed / 4.0);
	
	return h / float(oct);
}

void fragment() {
	vec2 size = v / UV;
	
	vec2 scUv = SCREEN_UV;
	
	vec2 motion = refractionMotion;
	motion.x -= windSpeed;
	
	vec2 refr = texture(refractionTexture, (worldV + motion * TIME) / refractionTiling).rg * 2.0 - 1.0;
	scUv += refr * refractionPower * SCREEN_PIXEL_SIZE;
	
	float h = GetWaveHeight();
	
	float diff = v.y - h;
	float t = clamp(diff / colorTransition, 0.0, 1.0);
	t = floor(t * colorTransitionSteps) / colorTransitionSteps;
	
	float borderTransition = v.x / limitTransition;
	borderTransition = min(borderTransition,
		(size.x - v.x) / limitTransition
	);
	borderTransition = clamp(borderTransition, 0.0, 1.0);
	h *= borderTransition;
	
	scUv = round(scUv / SCREEN_PIXEL_SIZE) * SCREEN_PIXEL_SIZE;
	
	vec4 col = textureLod(SCREEN_TEXTURE, scUv, 0.0);
	vec4 waterCol = mix(surfaceColor, mix(color, color2, t), step(h + surfaceSize, v.y));
	
	col.rgb = mix(col.rgb, waterCol.rgb, waterCol.a);
	
	COLOR = col;
	
	COLOR.a *= step(h, v.y);
}




"

[sub_resource type="OpenSimplexNoise" id=2]
octaves = 2

[sub_resource type="NoiseTexture" id=3]
flags = 3
width = 256
height = 256
seamless = true
as_normalmap = true
bump_strength = 32.0
noise = SubResource( 2 )

[resource]
shader = SubResource( 1 )
shader_param/worldMatrix = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 )
shader_param/color = Color( 0.501961, 0.996078, 1, 0.0941176 )
shader_param/color2 = Color( 0.333333, 0.678431, 0.862745, 0.294118 )
shader_param/surfaceColor = Color( 0.878431, 0.976471, 1, 0.968627 )
shader_param/surfaceSize = 2.0
shader_param/colorTransition = 32.0
shader_param/colorTransitionSteps = 8.0
shader_param/windSpeed = 32.0
shader_param/refractionMotion = Vector2( 0, -16 )
shader_param/refractionTiling = 64.0
shader_param/refractionPower = 8.0
shader_param/waveOctaves = 3
shader_param/wavePeriod = 64.0
shader_param/waveLacunarity = 2.384
shader_param/wavePersistance = 0.5
shader_param/limitTransition = 32.0
shader_param/refractionTexture = SubResource( 3 )
