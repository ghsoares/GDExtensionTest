[gd_resource type="ShaderMaterial" load_steps=7 format=2]

[ext_resource path="res://Textures/BayerMatrixDithering.png" type="Texture" id=1]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform sampler2D ditheringTexture;
uniform float ditheringInfluence = .1;

uniform sampler2D terrainHeightMap;
uniform vec2 terrainSize;
uniform float terrainResolution;

uniform sampler2D text;
uniform float tiling = 128f;
uniform float warpTiling = 256f;
uniform float warpAmnt = 32f;
uniform float easing = -2f;

uniform vec2 fadeRange = vec2(32f, 256f);
uniform vec3 fadeValues = vec3(1f, .5f, 0f);

uniform float threshold : hint_range(.0, 1) = .5f;
uniform float width : hint_range(.0, 1) = .25f;

uniform float widthDistortionTiling = 128f;
uniform float widthDistortionMagnitude : hint_range(0f, 1f) = .01f;
uniform float widthDistortionFrequency = 2f;
uniform float widthDistortionSpacing = 2f;

uniform sampler2D gradient;
uniform float energy = 1.0;

uniform float steps = 8f;

varying vec2 v;
varying float time;

float Ease(float x, float c) {if (x < 0f) x = 0f;if (x > 1f) x = 1f;if (c > 0f) {if (c < 1f) {return 1f - pow(1f - x, 1f / c);} else {return pow(x, c);}} else if (c < 0f) {if (x < 0.5f) {return pow(x * 2f, -c) * .5f;} else {return (1f - pow(1f - (x - .5f) * 2f, -c)) * .5f + .5f;}}return 0f;}

float SampleHeight() {return terrainSize.y * .5;}

float GetTerrainY() {return terrainSize.y - SampleHeight();}

void vertex() {
	v = VERTEX;
	time = TIME;
}

void TerrainColor(inout vec4 col) {
	vec2 pos = v;
	float height = SampleHeight();
	float heightDiff = pos.y - (terrainSize.y - height);
	
	vec2 textPixelSize = 1f / vec2(textureSize(text, 0));
	
	vec2 uv = pos / tiling;
	float n = texture(text, pos / warpTiling).r * radians(180f);
	
	uv += vec2(cos(n), sin(n)) * warpAmnt * textPixelSize;
	
	n = texture(text, uv).r;
	n = Ease(n, easing);
	
	float w = width;
	float dist = texture(text, pos / widthDistortionTiling).r;
	dist = sin((dist * widthDistortionSpacing + time * widthDistortionFrequency) * radians(360f));
	w += dist * widthDistortionMagnitude;
	w = max(w, 0f);
	
	n = 1f - abs(n - threshold) / (w * .5f);
	
	if (heightDiff < fadeRange.x) {
		float fadeT = heightDiff / fadeRange.x;
		n += mix(fadeValues.x, fadeValues.y, fadeT);
	} else {
		float fadeT = (heightDiff - fadeRange.x) / (fadeRange.y - fadeRange.x);
		fadeT = clamp(fadeT, 0, 1);
		n += mix(fadeValues.y, fadeValues.z, fadeT);
	}
	
	n = floor(n * steps) / steps;
	
	n = clamp(n, 0, 1);
	
	col *= texture(gradient, vec2(n));
	col.rgb *= (1.0 + energy);
}

void fragment() {
	TerrainColor(COLOR);
	
	COLOR.a *= step(GetTerrainY(), v.y);
}





"

[sub_resource type="Gradient" id=2]
offsets = PoolRealArray( 0, 0.861925, 1 )
colors = PoolColorArray( 0, 0, 0, 0, 1, 0, 0, 1, 1, 0.990234, 0, 1 )

[sub_resource type="GradientTexture" id=3]
gradient = SubResource( 2 )

[sub_resource type="OpenSimplexNoise" id=4]
octaves = 2

[sub_resource type="NoiseTexture" id=5]
seamless = true
noise = SubResource( 4 )

[resource]
shader = SubResource( 1 )
shader_param/ditheringInfluence = 0.05
shader_param/terrainSize = Vector2( 960, 540 )
shader_param/terrainResolution = 0.0
shader_param/tiling = 333.0
shader_param/warpTiling = 222.0
shader_param/warpAmnt = 64.0
shader_param/easing = -4.0
shader_param/fadeRange = Vector2( 64, 256 )
shader_param/fadeValues = Vector3( -1.377, -0.013, 0.709 )
shader_param/threshold = 0.291
shader_param/width = 0.16
shader_param/widthDistortionTiling = 256.0
shader_param/widthDistortionMagnitude = 0.025
shader_param/widthDistortionFrequency = 2.0
shader_param/widthDistortionSpacing = 4.0
shader_param/energy = 1.0
shader_param/steps = 8.0
shader_param/ditheringTexture = ExtResource( 1 )
shader_param/text = SubResource( 5 )
shader_param/gradient = SubResource( 3 )
